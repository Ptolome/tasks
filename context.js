const obj = {
  a: 1,
  b: function() {
    console.log(this.a)
  },
  c() {
    console.log(this.a)
  },
  d: () => {
    console.log(this.a)
  },
  e: (function() {
    return () => {
      console.log(this.a);
    }
  })(),
  f: function() {
    return () => {
      console.log(this.a);
    }
  }
}

console.log(obj.a) //1
obj.b()//1
;(obj.b)()//1 (obj.b)()то же самое, что и obj.b()
const b = obj.b
b() //undefined Когда мы сохраняем ссылку на obj.b в переменной, выполнение ее отдельно теряет ссылку на objи вместо этого будет указывать на window,
obj.b.apply({a: 2}) //2
obj.c() // 1  obj.cтакже является нормальной функцией, 
obj.d() // undefined obj.dявляется стрелочной функцией, поэтому она по сути заимствует область действия извне obj, чтоwindow
;(obj.d)()// undefined obj.dявляется стрелочной функцией, поэтому она по сути заимствует область действия извне obj, чтоwindow
obj.d.apply({a:2}) // undefined applyне будет иметь никакого значения для стрелочных функций и сохранит исходную thisпривязку, т.е.window
obj.e()//undefined
;(obj.e)() // undefined obj.eна самом деле является IIFE , поэтому thisссылается на windowи возвращает стрелочную функцию, следовательно, thisбудет брать свое значение из включающего контекста, т.е. это будет window.
obj.e.call({a:2})// undefined Опять же, callэто не будет иметь никакого значения для стрелочных функций, и сохранится исходная thisпривязка, т.е.window
obj.f()()//1 obj.fпохож на , eно главное отличие в том, что это обычная функция, поэтому thisуказывает на objвнутри нее. Функция стрелки внутри берет thisиз включающего контекста, следовательно, ссылается наobj
;(obj.f())()//1 То же, что и выше
obj.f().call({a:2})//1 callне будет иметь никакого значения для стрелочных функций и сохраняет исходную thisпривязку ie objи не {a: 2}. 